# -*- coding: utf-8 -*-
"""practica3_final.2_milenarivera.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O0NtiPdc17u8V7E18q6p0tHYTerfUehE
"""

#Los tries son estructuras de arbol utilizados para el almacenamiento de
#informaci√≥n, las cuales son construidas a partir de cadenas de caracteres.
#Su nombre proviene del ingles retrieve (el verbo recuperar en un contexto
#informatico). Estas estructuras sirven para la deteccion de errores,
#representacion de diccionarios computacionales, codificacion de informacion,
#entre otras aplicaciones.

#El objetivo principal de esta practica es la creacion y uso de tries de
#codificacion. Dado un alfabeto, se puede hacer una asignacion de este a
#cadenas binarias.

from google.colab import drive
import pandas as pd
drive.mount('/content/gdrive')

class Trie:
  '''
  Esta es mi clase que construira un trie a partir de un excel y tendra los
  metodos para codificar y decodificar una cadena de caracteres que contengan
  caracteres proporcionados por el excel.
  '''
  def __init__(self, excel):
    '''
    Este sera mi constructor que reciba un archivo excel que contenga las
    columnas 'Letters' y 'Binary coding' y a partir de el construira una
    representacion del Trie que guardara en su atributo 'self.raiz'.
    '''
    self.excel = excel
    #leo mi excel y lo hago un data frame
    self.df = pd.read_excel(r'/content/gdrive/MyDrive/programacion24_2/'+
                            self.excel, dtype={'Binary coding': str})
    #necesito hacer el df diccionario que relacione {caracter: binary code}
    self.diccionario = dict(zip(self.df['Letters'], self.df['Binary coding']))
    #print('Leo esto del excel: ', self.diccionario)

    #inicializo el trie con una raiz igual a una cadena vacia como clave inicial
    self.raiz = {'': {}}
    for key, value in self.diccionario.items():
        trie = self.raiz['']
        for val in value:
          #considero el caso donde val es distinto de 0 o 1
          if val not in ['0', '1']:
            raise ValueError(f'Valor no valido en Binary coding: {val}. ' +
                             'Debe ser 0 o 1.')
          if val not in trie:
            trie[val] = {}
          trie = trie[val]
        trie[key] = '__fin__' #asigno el caracter como llave al final del trie
        #mi final es de la forma {...{'caracter':'__fin__'}}

  def arreglar_trie(self):
    '''
    Este sera un metodo para arreglar el caso del diccionario que se crea al
    final cuando ya se elaboro 'la red' que conecta la raiz con una caracter.
    Simplemente remplazara el diccionario final de la forma {'x':'__fin__'} por
    'x'.
    '''
    self.raiz2 = self.raiz
    def arreglar(dic):
      '''
      Esta es una funcion auxiliar recursiva para intercambiar el ultimo
      diccionario con valor == '__fin__' por el valor que le corresponde.
      Recibe diccionarios porque el Trie son diccionarios anidados.
      '''
      for key, valor in dic.items():
        if isinstance(valor, dict):
          arreglar(valor)
          if '__fin__' in valor.values():
            for car, fin in valor.items():
              dic[key] = car

    arreglar(self.raiz2)
    return self.raiz2

  def codificacion(self, txt_normal):
    '''
    Este sera un metodo de codificacion que a partir de un Trie construido y
    una cadena de caracteres que incluya las letras del alfabeto que esten
    en el Trie construido, regresara el texto codificado en forma de cadena.

    NOTA: Para caracteres que no esten contenidos en el Trie no los codifica
    simplemente los regresa iguales y avisa que caracter es.
    '''
    #inicializo mi cadena vacia
    codificacion = ''

    #este es un metodo auxiliar que necesito para codificar
    def encontrar_keys_con_valor(dic, valor_objetivo, camino = ''):
      '''
      Este es un metodo auxiliar que ayudara a codificar una cadena de
      caracteres que pertenezcan al trie. Recibe un diccionario anidado (Trie
      o parte del Trie) y un valor que sera un caracter. Regresa una cadena
      con las keys que me llevan al valor que conozco.
      '''
      for key, valor in dic.items():
        mi_camino = camino + key
        if isinstance(valor, dict):
            # recuerda: trie es diccionario anidado
            camino_anidado = encontrar_keys_con_valor(valor, valor_objetivo,
                                                      mi_camino)
            if camino_anidado:
                return camino_anidado
        elif valor == valor_objetivo: #checo si es lo que busco
            return mi_camino
      if len(mi_camino) == 0: #si no lo encuentro aviso
        print(f'El valor {valor_objetivo} no existe en el Trie.')
        return valor_objetivo
      return ''

    for i in txt_normal:
      codicicacion_i = encontrar_keys_con_valor(self.raiz2, i)
      #agregamos el texto codificado a la cadena final
      codificacion += codicicacion_i
    return codificacion

  def decodificacion(self, txt_codificado):
    '''
    Este sera un metodo de decodificacion a partir de un Trie construido y un
    texto dado. Recibira un numero entero binario y regresara el texto
    decodificado en forma de cadena.

    NOTA: En caso de que el entero binario contenga valores distintos a los que
    estan dentro del trie, se levantara un error de valor. Por otro lado, si
    este si contiene valores del trie pero no a todos les corresponde un
    caracter del Trie, solamente regresara los que logro decodificar.
    En caso de que no haya decodificado ninguno levantara una excepcion.
    '''
    txt_decodificado = '' #inicializo una cadena vacia
    #trataremos al trie como grafica donde cada nodo es un valor del diccionario
    nodo = self.raiz2['']
    for numero in txt_codificado:
      try:
        nodo = nodo[numero]
        if isinstance(nodo, str):#verificamos si llegamos al final de una cadena
          txt_decodificado += nodo #agregamos la letra al texto decodificado
          #regresamos al nodo raiz para iniciar con la siguiente cadena
          nodo = self.raiz2['']
      except KeyError:
        #considero el caso donde el texto codificado incluya valores distintos
        #a los que estan en el Trie
        raise ValueError('Caracter no valido en el texto codificado.')
    if not txt_decodificado:
      raise Exception('No se puede decodificar toda la cadena.')

    return txt_decodificado

def main():
  '''
  Este es mi programa principal. En particular utilice el ejemplo proporcionado
  en la practica para verificar que funcionara. Al final tiene un ejemplo
  personal de codificacion.
  '''
  #elijo el archivo con el que hare mi trie
  archivo_prueba = 'Code.xlsx'

  #hago mi trie
  mi_trie = Trie(archivo_prueba)
  #print('Mi trie inicial: ', mi_trie.raiz)

  #arreglo el caso final (es importante para acceder a self.raiz2)
  mi_trie_corregido = mi_trie.arreglar_trie()
  print('Mi Trie:', mi_trie_corregido)

  #ejemplo de decodificacion
  with open('/content/gdrive/MyDrive/programacion24_2/Mensaje.txt','r') as infile:
    for line in infile:
      print('Este es el ejemplo: ', line)
      resultado = mi_trie.decodificacion(line)
      print('Esto decodifique: ', resultado)

  #ejemplo de codificacion
  texto_para_codificar = 'Mi perro se llama holmes!'
  #NOTA: tambien puede recibir un archivo .txt solo seria agregar un with open
  resultado2 = mi_trie.codificacion(texto_para_codificar)
  print('Texto codificado:', resultado2)

if __name__ == "__main__":
  main()