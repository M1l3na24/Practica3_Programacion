# -*- coding: utf-8 -*-
"""practica3_final_milenarivera.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O0NtiPdc17u8V7E18q6p0tHYTerfUehE
"""

#Los tries son estructuras de arbol utilizados para el almacenamiento de
#información, las cuales son construidas a partir de cadenas de caracteres.
#Su nombre proviene del ingles retrieve (el verbo recuperar en un contexto
#informatico). Estas estructuras sirven para la deteccion de errores,
#representacion de diccionarios computacionales, codificacion de informacion,
#entre otras aplicaciones.

#El objetivo principal de esta practica es la creacion y uso de tries de
#codificacion. Dado un alfabeto, se puede hacer una asignacion de este a
#cadenas binarias.

from google.colab import drive
import pandas as pd
drive.mount('/content/gdrive')

#mi clase de Tries
class Trie:
  '''
  Esta es mi clase que construira un trie a partir de un excel y tendra los
  metodos para codificar y decodificar una cadena de caracteres que contengan
  caracteres proporcionados por el excel.
  '''

#(I) El metodo de construccion debe de recibir un archivo excel que contenga
#las columnas Letras y Cadenas el cual debe de construir una representación
#del trie:
  def __init__(self, excel):
    '''
    Este sera mi constructor que reciba un archivo excel que contenga las
    columnas 'Letters' y 'Binary coding' y a partir de el construira una
    representacion del Trie que guardara en su atributo self.raiz.
    '''
    self.excel = excel #el excel propio
    #leo mi excel y lo hago un data frame
    self.df = pd.read_excel(r'/content/gdrive/MyDrive/programacion24_2/'+
                            self.excel, dtype={'Binary coding': str})
    #necesito hacer el df en un diccionario que relacione
    #{caracter: binary code}
    self.diccionario = dict(zip(self.df['Letters'], self.df['Binary coding']))
    #print('Leo esto del excel: ', self.diccionario)

    #inicializo el trie con una raiz = una cadena vacia como clave inicial
    self.raiz = {'': {}}
    for key, value in self.diccionario.items():
        trie = self.raiz['']
        for val in value:
          #considero el caso donde val es distinto de 0 o 1
          if val not in ['0', '1']:
            raise ValueError(f"Valor no valido en Binary coding: {val}. Debe ser 0 o 1.")
          if val not in trie:
            trie[val] = {}
          trie = trie[val]
        trie[key] = '__fin__'  #asigno la letra como valor al final de la cadena
        #mi final es de la forma {...{'caracter':'__fin__'}}
    #todo el trie esta guardado en self.raiz

  def arreglar_trie(self):
    '''
    Este sera un metodo para arreglar el caso del diccionario que se crea al
    final cuando ya se elaboro 'la red' que conecta la raiz con una letra.
    Simplemente remplazara el diccionario final de la forma {'x':'__fin__'} por
    'x'.
    '''
    self.raiz2 = self.raiz
    def arreglar(dic):
      '''
      Esta es una funcion auxiliar recursiva para intercambiar el ultimo
      diccionario con valor == '__fin__' por el valor que le corresponde.
      Recibe diccionarios porque el trie son diccionarios anidados.
      '''
      for key, valor in dic.items():
        if isinstance(valor, dict):
          arreglar(valor)
          if '__fin__' in valor.values():
            for car, fin in valor.items():
              dic[key] = car

    arreglar(self.raiz2)
    return self.raiz2

#(II) Debe de tener un metodo codificacion que reciba una cadena de caracteres
#que incluya las letras del alfabeto de construccion y regrese el entero
#binario que codifique a la palabra.
  def codificacion(self, txt_normal):
    '''
    Este sera un metodo de codificacion que a partir de un trie construido y
    una cadena de caracteres que incluya las letras del alfabeto que esten
    en el trie construido, regresara el texto codificado en forma de cadena.

    NOTA: Para caracteres que no esten contenidos en mi trie no los codifica
    simplemente los regresa iguales y avisa que caracter es.
    '''
    #inicializo mi cadena vacia
    codificacion = ''

    #este es un metodo auxiliar que necesito para codificar
    def encontrar_keys_con_valor(dic, valor_objetivo, camino = ''):
      '''
      Este es un metodo auxiliar que ayudara a codificar una cadena de
      caracteres que pertenezcan al trie. Recibe un diccionario anidado, (trie
      o parte del trie) y un valor que sera un caracter. Regresa una cadena
      con las keys que me llevan al valor que conozco.
      '''
      for key, valor in dic.items():
        mi_camino = camino + key
        if isinstance(valor, dict):
            # recuerda: trie es diccionario anidado
            camino_anidado = encontrar_keys_con_valor(valor, valor_objetivo, mi_camino)
            if camino_anidado:
                return camino_anidado
        elif valor == valor_objetivo: #checo si es lo que busco
            return mi_camino
      if len(mi_camino) == 0: #si no lo encuentro aviso
        print(f"El valor {valor_objetivo} no existe en el Trie.")
        return valor_objetivo
      return ''

    for i in txt_normal:
      codicicacion_i = encontrar_keys_con_valor(self.raiz2, i)
      #agregamos el texto codificado a la cadena final
      codificacion += codicicacion_i
    return codificacion


#(III) Debe de tener un metodo decodificacion que reciba un numero entero
#binario y regrese la cadena decodificada.
  def decodificacion(self, txt_codificado):
    '''
    Este sera un metodo de decodificacion a partir de un trie construido y un
    texto dado. Recibira un numero entero binario y regresara el texto
    decodificado en forma de cadena.
    '''
    self.txt_decodificado = '' #inicializo una cadena vacia
    #trataremos al trie como grafica donde cada nodo es un valor del diccionario
    nodo = self.raiz2['']
    for numero in txt_codificado:
      try:
        nodo = nodo[numero]
        if isinstance(nodo, str):#verificamos si llegamos al final de una cadena
          self.txt_decodificado += nodo#agregamos la letra al texto decodificado
          #regresamos al nodo raiz para iniciar con la siguiente cadena
          nodo = self.raiz2['']
      except KeyError:
        #considero el caso donde el texto codificado incluya valores distintos
        #a los que estan en el trie
        raise ValueError("Cadena no valida en el texto codificado.")

    return self.txt_decodificado


def main():
  '''
  Este es mi programa principal. En particular utilice el ejemplo proporcionado
  en la practica para verificar que funcionara. Al final tiene un ejemplo
  personal de codificacion
  '''
  #elijo el archivo con el que hare mi trie
  archivo_prueba = 'Code.xlsx'

  #hago mi trie
  mi_trie = Trie(archivo_prueba)
  #print('Mi trie inicial: ', mi_trie.raiz)

  #arreglo el caso final
  mi_trie_corregido = mi_trie.arreglar_trie()
  print('Mi Trie:', mi_trie_corregido)

  #ejemplo de decodificacion
  with open('/content/gdrive/MyDrive/programacion24_2/Mensaje.txt','r') as infile:
    for line in infile:
      print('Este es el ejemplo: ', line)
      resultado = mi_trie.decodificacion(line)
      print('Esto decodifique: ', resultado)

  #ejemplo de codificacion
  texto_para_codificar = 'Mi perro se llama holmes!'
  #nota: tambien puede recibir un archivo solo seria agregar un with open
  resultado2 = mi_trie.codificacion(texto_para_codificar)
  print('Texto codificado:', resultado2)

if __name__ == "__main__":
  main()